%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"

extern FILE *outfp;
char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break labels */
/* label _L0 is a break without a while/switch) */

static char *extrns[100]; /* emit externs at the end only */
static int extcnt;
extern int localPos;

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static void outstr(char *s) {
  while (*s) fprintf(outfp, pfCHAR, (unsigned char)*s++);
  fprintf(outfp, pfCHAR, 0);
}

int functionReturnType;

static char *mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}
/*use to determine function return type*/
int isIntFunction(Node* p) {return p->info == 1 ? 1 : MAX_COST;}
/*use to determine if LOCAL or ID is int*/
int isInt(Node* p) {return p->info == 1 ? 1 : MAX_COST;}
/*use to determine if LVAL of ATR is Int*/
int isIntLval(Node* p) {return RIGHT_CHILD(p)->info == 1 ? 1 : MAX_COST;}


/*use to determine function return type*/
int isRealFunction(Node* p) {return p->info == 3 ? 1 : MAX_COST;}
/*use to determine if LOCAL or ID is int*/
int isReal(Node* p) {return p->info == 3 ? 1 : MAX_COST;}
/*use to determine if LVAL of ATR is Real*/
int isRealLval(Node* p) {return RIGHT_CHILD(p)->info == 3 ? 1 : MAX_COST;}

int isString(Node* p) {return p->info == 2 ? 1 : MAX_COST;}
int isStringFunction(Node* p) {return p->info == 2 ? 1 : MAX_COST;}
int isStringLval(Node* p) {return RIGHT_CHILD(p)->info == 2 ? 1 : MAX_COST;}


int isIntPointer(Node* p) {return p->info == 11 ? 1 : MAX_COST;}

%}
%term INSTR=';' BLOCK='{' ARGB='(' NEXT=','
%term FACTORIAL='!' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%'
%term LT='<' GT='>' LOGIC_EQUAL='=' AND='&' OR='|' LOGIC_NOT='~'
%term INDEX='['
%include "y.tab.h"
%%

finit: ARGB(bloco, params) 1 {if (functionReturnType == 1 || functionReturnType == 2)fprintf(outfp, pfLOCAL pfLOAD pfPOP, 8); else if(functionReturnType == 3) fprintf(outfp, pfLOCAL pfLOAD2 pfDPOP, 8);}
finit: ARGB(bloco, NIL) 1 {if (functionReturnType == 1 || functionReturnType == 2) fprintf(outfp, pfLOCAL pfLOAD pfPOP, 8); else if(functionReturnType == 3) fprintf(outfp, pfLOCAL pfLOAD2 pfDPOP, 8);}

params: param
params:NEXT(params, param)

bloco: BLOCK(list, decls)

decls: INSTR(decls, param)
decls: NONE

param: PARAM(tipo, ID)

tipo: INTEGER
tipo: STRING
tipo: NUMBER

%! one or more complete expressions
list: base
list: LIST(list, base)

%!end of an expression is a base
base: expr 1 {fprintf(outfp, pfTRASH, (int)p->place); }



%!an expression is any type of expression
expr: iexpr {p->place = 4;}
expr: sexpr {p->place = 4;}
expr: rexpr {p->place = 8;}

%!any type of function
expr: CALL(ID, arguments) 1 {fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)((RIGHT_CHILD(p)->place))); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}

expr: CALL(ID, VOID) 1 {fprintf(outfp, pfCALL pfPUSH, mkfunc(LEFT_CHILD(p)->value.s)); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}


%!lval is an expression on the left side of an assignment
lval: LOCAL 1 {fprintf(outfp, pfLOCAL, p->value.i * (pfWORD/4));}
lval: ID 1 {fprintf(outfp, pfADDR, p->value.s);}

lvec: lval 1 {fprintf(outfp, pfLOAD);}
lval: INDEX(lvec, expr) 1 { fprintf(outfp, pfIMM pfMUL pfADD,
							LEFT_CHILD(p)->info == 13 ? 8 : 4);}

%! expressions relating to strings
sexpr:	STR	1	{	lbl++; fprintf(outfp, pfRODATA pfALIGN pfLABEL, mklbl(lbl));
					outstr(p->value.s); fprintf(outfp, pfTEXT pfADDR, mklbl(lbl));}
sexpr: PTR(LOCAL) isString {fprintf(outfp, pfLOCV, LEFT_CHILD(p)->value.i);}
sassign: sexpr 1 {fprintf(outfp, pfDUP);}
sassign: iptrexpr 1 {fprintf(outfp, pfDUP);}
%!sassign: iexpr 1 {fprintf(outfp, pfDUP); /*can assign integer to strings*/}
sexpr: ATR(sassign, lval) isStringLval {fprintf(outfp, pfSTORE);}

sexpr: CALL(ID, arguments) isStringFunction {fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)((RIGHT_CHILD(p)->place))); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}

sexpr: CALL(ID, VOID) isStringFunction {fprintf(outfp, pfCALL pfPUSH, mkfunc(LEFT_CHILD(p)->value.s)); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}

scmp: sexpr {fprintf(outfp, pfLOAD);}

iexpr: LT(scmp, scmp) 1 {fprintf(outfp, pfLT);}
iexpr: GT(scmp, scmp) 1 {fprintf(outfp, pfGT);}
iexpr: GE(scmp, scmp) 1 {fprintf(outfp, pfGE);}
iexpr: LE(scmp, scmp) 1 {fprintf(outfp, pfLE);}
iexpr: NE(scmp, scmp) 1 {fprintf(outfp, pfNE);}
iexpr: LOGIC_EQUAL(scmp, scmp) 1 {fprintf(outfp, pfEQ);}
iexpr: AND(scmp, scmp) 1 {fprintf(outfp, pfAND);}
iexpr: OR (scmp, scmp) 1 {fprintf(outfp, pfOR);}



%! expressions relating to integers
iassign: iexpr 1 {fprintf(outfp, pfDUP);}
iexpr: INT 1 {fprintf(outfp, pfIMM, p->value.i);}
iexpr: ATR(iassign, lval) isIntLval {fprintf(outfp, pfSTORE);}
iexpr: ADD(iexpr, iexpr) 1 {fprintf(outfp, pfADD);}
iexpr: SUB(iexpr, iexpr) 1 {fprintf(outfp, pfSUB);}
iexpr: DIV(iexpr, iexpr) 1 {fprintf(outfp, pfDIV);}
iexpr: MOD(iexpr, iexpr) 1 {fprintf(outfp, pfMOD);}
iexpr: MUL(iexpr, iexpr) 1 {fprintf(outfp, pfMUL);}
iexpr: LT(iexpr, iexpr) 1 {fprintf(outfp, pfLT);}
iexpr: GT(iexpr, iexpr) 1 {fprintf(outfp, pfGT);}
iexpr: GE(iexpr, iexpr) 1 {fprintf(outfp, pfGE);}
iexpr: LE(iexpr, iexpr) 1 {fprintf(outfp, pfLE);}
iexpr: NE(iexpr, iexpr) 1 {fprintf(outfp, pfNE);}
iexpr: LOGIC_EQUAL(iexpr, iexpr) 1 {fprintf(outfp, pfEQ);}
iexpr: AND(iexpr, iexpr) 1 {fprintf(outfp, pfAND);}
iexpr: OR (iexpr, iexpr) 1 {fprintf(outfp, pfOR);}
iexpr: FACTORIAL(iexpr) 1 {/*fprintf(outfp)*/ /*FIXME*/}
iexpr: LOGIC_NOT(iexpr) 1 {fprintf(outfp, pfNOT);}
iexpr: UMINUS(iexpr) 1 {fprintf(outfp, pfNEG);}
%!iexpr: REF(LOCAL) 1 {fprintf(outfp, pfLOAD)}

%!integer := <real number>
iexpr: rexpr 3 {fprintf(outfp, pfD2I);}

%!increment and decrement integer only
iexpr: INCR(lval) 1 {fprintf(outfp, pfDUP pfINCR pfLOAD, 1);}
iexpr: DECR(lval) 1 {fprintf(outfp, pfDUP pfDECR pfLOAD, 1);}
iexpr: POSINC(lval) 1 {fprintf(outfp, pfDUP pfLOAD pfSWAP pfINCR, 1);}
iexpr: POSDEC(lval) 1 {fprintf(outfp, pfDUP pfLOAD pfSWAP pfDECR, 1);}

%! assign integers to IDS
iexpr: PTR(LOCAL) isInt {fprintf(outfp, pfLOCV, LEFT_CHILD(p)->value.i);}
%!FIXMEiexpr: PTR(ID) isInt {fprintf(outfp, pfADDR pfLOAD, LEFT_CHILD(p)->value.s);}

%!integer expression is a function that returns int
iexpr: CALL(ID, arguments) isIntFunction {fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)((RIGHT_CHILD(p)->place))); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}

iexpr: CALL(ID, VOID) isIntFunction {fprintf(outfp, pfCALL pfPUSH, mkfunc(LEFT_CHILD(p)->value.s)); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}



%! comparisons between real expressions return int
iexpr: LT(rexpr, rexpr) 1 {fprintf(outfp, pfDCMP pfIMM pfLT, 0);}
iexpr: GT(rexpr, rexpr) 1 {fprintf(outfp, pfDCMP pfIMM pfGT, 0);}
iexpr: GE(rexpr, rexpr) 1 {fprintf(outfp, pfDCMP pfIMM pfGE, 0);}
iexpr: LE(rexpr, rexpr) 1 {fprintf(outfp, pfDCMP pfIMM pfLE, 0);}
iexpr: LOGIC_EQUAL(rexpr, rexpr) 1 {fprintf(outfp, pfDCMP pfIMM pfEQ, 0);}
iexpr: NE(rexpr, rexpr) 1 {fprintf(outfp, pfDCMP pfIMM pfNE, 0);}


iptrexpr: REF(LOCAL) isIntPointer {fprintf(outfp, pfLOCAL, LEFT_CHILD(p)->value.i);}


%! expressions relating to real numbers
rexpr: ATR(rassign, lval) isRealLval {fprintf(outfp, pfSTORE2);}
rassign: rexpr 1 {fprintf(outfp, pfDUP2);}
rexpr: REAL 1 {lbl++; fprintf(outfp, pfRODATA pfALIGN pfLABEL pfDOUBLE, mklbl(lbl), p->value.r);
					fprintf(outfp, pfTEXT pfADDR pfLOAD2, mklbl(lbl));}
rexpr: ADD(rexpr, rexpr) 1 {fprintf(outfp, pfDADD);}
rexpr: UMINUS(rexpr) 1 {fprintf(outfp, pfDNEG);}
rexpr: SUB(rexpr, rexpr) 1 {fprintf(outfp, pfDSUB);}
rexpr: MUL(rexpr, rexpr) 1 {fprintf(outfp, pfDMUL);}
rexpr: DIV(rexpr, rexpr) 1 {fprintf(outfp, pfDDIV);}
rexpr: iexpr 1 {fprintf(outfp, pfI2D);}

%!assign reals to IDS
rexpr: PTR(LOCAL) isReal {fprintf(outfp, pfLOCAL pfLOAD2, LEFT_CHILD(p)->value.i);}
%!FIXME PTR(ID) isReal {fprintf(outfp, pfADDR pfLOAD2, LEFT_CHILD(p)->value.s);}

%!real expression is a function that returns real
rexpr: CALL(ID, arguments) isRealFunction {fprintf(outfp, pfCALL pfTRASH pfDPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)((RIGHT_CHILD(p)->place))); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}

rexpr: CALL(ID, VOID) isRealFunction {fprintf(outfp, pfCALL pfDPUSH, mkfunc(LEFT_CHILD(p)->value.s)); p->place = IDfind(LEFT_CHILD(p)->value.s, NULL) == 3 ? 8: 4;}

%!Arguments of function calls
arguments: ARGS(NIL, expr) {p->place = RIGHT_CHILD(p)->place; }
arguments: ARGS(arguments, expr) {p->place = LEFT_CHILD(p)->place + RIGHT_CHILD(p)->place;}


%%
#include "y.tab.h"
extern void yyerror(const char*);
extern char **yynames;
extern int trace;
extern int localCounter;

void externs()
{
  int i;

  for (i = 0; i < extcnt; i++)
    if (extrns[i])
      fprintf(outfp, pfEXTRN, extrns[i]);
}


void function(int pub, Node *type, char *name, Node *body)
{
	Node *bloco = LEFT_CHILD(body);
	IDpop();
	if (bloco != 0) { /* not a forward declaration */
		long par;
		int fwd = IDfind(name, &par);
		if (fwd > 40) yyerror("duplicate function");
		else {
			IDreplace(fwd+40, name, par);
			fflush(stdout);
  		fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), - localPos * (pfWORD/4));
  		functionReturnType = type->value.i;
  		//printNode(body, stdout, yynames);
  		yyselect(body);
  		fprintf(outfp, pfLEAVE pfRET); /* just in case ... */
			freeNode(body);
			for (int i = 0; i < extcnt; i++)
		    if (extrns[i] && strcmp(extrns[i], mkfunc(name)) == 0) extrns[i] = 0;
		}
	}
	else {
		char* buffer = (char*) malloc(sizeof(char) * 80);
		*buffer = '\0';
  		strcpy(buffer, "_");
  		strcat(buffer, name);
		extrns[extcnt++] = buffer;
	}
}


void declare(int pub, int cnst, Node *type, char *name, Node *value)
{
  int typ;
  if (!value) {
    if (!pub && cnst) yyerror("local constants must be initialised");

    //if (pub && !cnst) {
    //	variable is extern
    //	fprintf(outfp, pfEXTRN, name);
    //if(!pub && !cnst) {

    //}
    //}
    //}

    return;
  }
  if (value->attrib = INT && value->value.i == 0 && type->value.i > 10)
  	return; /* NULL pointer */
  if ((typ = value->info) % 10 > 5) typ -= 5;
  if (type->value.i != typ)
    yyerror("wrong types in initialization");
}
