%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"

extern FILE *outfp;
char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break labels */
/* label _L0 is a break without a while/switch) */

static char *extrns[100]; /* emit externs at the end only */
static int extcnt;
extern int localPos;

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static void outstr(char *s) {
  while (*s) fprintf(outfp, pfCHAR, (unsigned char)*s++);
  fprintf(outfp, pfCHAR, 0);
}
static char *mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}
%}
%term INSTR=';' BLOCK='{' ARGB='(' NEXT=',' ASSIGN='='
%include "y.tab.h"
%%

finit: ARGB(bloco, params)

params: param
params:NEXT(params, param)

bloco: BLOCK(list, decls)

decls: INSTR(decls, param)
decls: NONE

param: PARAM(tipo, ID)

tipo: INTEGER
tipo: STRING
tipo: NUMBER

list: base
list: LIST(list, base)

base: expr 1 {fprintf(outfp, pfTRASH, pfWORD); }


lval: LOCAL 1 {fprintf(outfp, pfLOCAL, p->value.i * (pfWORD/4));}


expr: CALL(ID, arguments) 1 {fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)((RIGHT_CHILD(p)->place)));}


arguments: ARGS(NIL, expr) {p->place = 4; }
arguments: ARGS(arguments, expr) {p->place = LEFT_CHILD(p)->place + 4;}


expr:	STR	1	{	 lbl++; fprintf(outfp, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); 
					outstr(p->value.s); fprintf(outfp, pfTEXT pfADDR, mklbl(lbl));}

expr: INT 1 {fprintf(outfp, pfIMM, p->value.i);}
expr: ATR(expr, lval) 1 {fprintf(outfp, pfSTORE);}

%%
#include "y.tab.h"
extern void yyerror(const char*);
extern char **yynames;
extern int trace;
extern int localCounter;

void externs()
{
  int i;

  for (i = 0; i < extcnt; i++)
    if (extrns[i])
      fprintf(outfp, pfEXTRN, extrns[i]);
}


void function(int pub, Node *type, char *name, Node *body)
{
	Node *bloco = LEFT_CHILD(body);
	IDpop();
	if (bloco != 0) { /* not a forward declaration */
		long par;
		int fwd = IDfind(name, &par);
		if (fwd > 40) yyerror("duplicate function");
		else {
		IDreplace(fwd+40, name, par);

		fflush(stdout);
  		fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), - localPos * (pfWORD/4));
  		yyselect(body);
  		fprintf(outfp, pfLEAVE pfRET); /* just in case ... */
		freeNode(body);
		
		for (int i = 0; i < extcnt; i++)
		    if (extrns[i] && strcmp(extrns[i], mkfunc(name)) == 0) extrns[i] = 0;


		}
	}
	else {
		char* buffer = (char*) malloc(sizeof(char) * 80);
		*buffer = '\0';
  		strcpy(buffer, "_");
  		strcat(buffer, name);
		extrns[extcnt++] = buffer;
	}
}
